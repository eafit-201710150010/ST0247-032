Numeral 3.3
Se usan dos listas (arrayList), una que representa las longitudes de rutas en la mañana y otra en la tarde. Se ordenan de menor a mayor con el método Collections.sort() y se busca asignar a cada conductor al principio la ruta máxima en la mañana que no haya sido asignada en el pasado, y luego intentar asignarle la ruta máxima no asignada en la tarde sin pasarse de d, en cuyo caso se le asigna la segunda más larga o así sucesivamente siempre evitando que se pase de d. Así se hace una mejor distribución de los turnos y rutas Y se minimiza el costo extra a pagar.  

Numeral 3.4 La complejidad

package lab4;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;

/**
 *
 * @author ljpalaciom
 */
public class ejercicioEnLinea {

    public static void main(String[] args) {
        BufferedReader lector = new BufferedReader(new InputStreamReader(System.in));
        ArrayList<Integer> qManana = new ArrayList<>();
        ArrayList<Integer> qTarde = new ArrayList<>();
        try {
            while (true) { 
                String lineaPartida[] = lector.readLine().split(" ");
                int n = Integer.parseInt(lineaPartida[0]);
                int d = Integer.parseInt(lineaPartida[1]);
                int r = Integer.parseInt(lineaPartida[2]);
                if (n == 0) {
                    break;
                }
                lineaPartida = lector.readLine().split(" "); 
                for (String hora : lineaPartida) { 
                    qManana.add(Integer.parseInt(hora)); 
                }
                lineaPartida = lector.readLine().split(" ");
                for (String hora : lineaPartida) {
                    qTarde.add(Integer.parseInt(hora));
                }
                int dineroExtra = 0;
                int acum;
                Collections.sort(qManana); nLog(n)
                Collections.sort(qTarde ); nLog(n)
                for (int i = 0; i < n; i++) { C1n
                    acum = qManana.remove(qManana.size() - 1); C2n
                    boolean entre = false; C3n
                    int next = 0; C4n
                    for (int j = qTarde.size() - 1; j >= 0; j--) { C5n*n
                        next = qTarde.get(j);C6n*n
                        if (acum + next <= d) {C7n*n
                            qTarde.remove(j); C8*n
                            entre = true; C9*n
                            break;
                        }
                    }
                    if (!entre) {
                        qTarde.remove(0);
                        acum += next - d;
                        dineroExtra += acum * r;
                    }
                }
                System.out.println(dineroExtra);
            }
        } catch (Exception e) {
        }
    }
    
}
T(n) = 2nlogn + Cn +  C'n*n
T(n) es O(2nlogn + Cn + C'n*n)
T(n) es O(C'n*n)
T(n) es O(n*n)
T(n) es O(n^2)
Esta complejidad no tiene en cuenta el tiempo que se toma ingresar los datos, sino la solución con los mismos.

3.5
La variable n se refiere a las n rutas del bus, n en la mañana, n en la tarde, y a los n conductores del bus.